<DOCTYPE html>
  <html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Modelo de uso do MathJax (HTML+Latex)</title>

    <!-- MATHJAX 3 (através da CDN) -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- MATHJAX 3 (salvo no computador) -->
    <!-- <script type="text/javascript" async src="../../../Aplicativos/MathJax-master/es5/tex-mml-chtml.js" async></script> -->
  </head>

  <body>
    <p>
      <strong>ATENÇãO 1:</strong> Essa atividade deve ser entregue
      no formato MathJax (html + Latex)
      diretamente pelo Moodle. Não serão aceitas soluções em papel ou escaneadas.
      Junto com esta atividade, estou fornecendo
      o arquivo que eu usei para prepará-la. Leia-o e veja como eu fiz para escrever estas questões.
      Os alunos que ainda tiverem dúvida sobre o formato podem pedir ajuda no
      grupo do telegram.
    </p>

    <p>
      <strong>ATENÇãO 2:</strong> Ao copiar a sua atividade para o editor de código html
      do Moodle, NÃO copie todo o conteúdo do arquivo HTML.
      Ao invés disso, copie apenas o conteúdo que está dentro das
      tags <strong>body</strong> do html. O Moodle já tratará de renderizar.
      Se ainda restar dúvida, por favor assista ao vídeo em que eu
      mostro como preparar e enviar as atividades pelo Moodle.
    </p>

    <h1>Questões</h1>

    <ul>
      <li>
        <p><strong>Questão 1 (Partição).</strong> A entrada é uma lista \( L[1..n] \)
          de números, com \(n \geq 1\). Lembre-se que os nossos arrays
          nessa disciplina começam com o índice \(1\). O elemento \(L[1]\) é chamado de pivô. Seja \(k\)
          o número de elementos de \(L\) com valor menor ou igual ao pivô.
          Seu objetivo é especificar um algoritmo
          de <strong>tempo linear</strong> \(\Theta(n)\) para reorganizar
          os elementos de \(L\) de modo que as três condições a seguir
          sejam satisfeitas:
        <ul>
          <li>O pivô \(L[1]\) seja reposicionado para a posição \(k\).</li>
          <li>Os elementos com valor menor ou igual ao pivô sejam colocados nas \(k\)
            primeiras posições.</li>
          <li>Os elementos com valor maior que o pivô sejam colocados nas últimas \(n-k\) posições.</li>
        </ul>
        <p><strong>Obs. 1:</strong> Este problema poderia ser resolvido simplesmente ordenando a lista,
          mas neste caso gastaria tempo \(\Theta(n\log{n})\).</p>
        <p><strong>Obs. 2:</strong> Este algoritmo é utilizado pelo algoritmo de ordenação Quicksort.</p>

        <p>
          <strong>Passos Básicos:</strong> Utilize dois índices \(i\) e \(j\).
          O índice \(i\) vai da posição \(2\) em direção em final da lista, e o índice \(j\)
          vai da última posição em direção ao início da lista. Em cada iteração, avançe o \(i\)
          se \(L[i]\) é menor ou igual ao pivô. Caso contrário, avançe o \(j\) se \(L[j]\)
          é maior que o pivô. Se nenhuma destas condições ocorrer, troque \(L[i]\) com \(L[j]\)
          e avance \(i\) e \(j\). A repetição termina quando \(j &lt; i\).
          Finalmente, reposicione o pivô de modo que apenas elementos maiores
          que o pivô estejam à direita dele.
        </p>

        <p><strong>Invariante de loop:</strong><br>
          INV1: Todos os elementos nas posições menores que \(i\) possuem valor menor ou igual ao pivô.<br>
          INV2: Todos os elementos nas posições maiores que \(j\) possuem valor maior que o pivô.
        </p>
        <p>
        <ol type="a">
          <li>Forneça uma medida de progresso, e argumente que o algoritmo termina.</li>
          <li>Indique como estabelecer o invariante do loop, ou seja, quais ações
            no código pré-loop tornam o invariante do loop verdadeiro na primeira iteração. Justifique.</li>
          <li>Qual o código do loop? Argumente que ele mantém o invariante do loop.</li>
          <li>Argumente que o invariante do loop e a condição de saída garantem que,
            assim que a execução sair do loop teremos \(j = i-1\).</li>
          <li>Qual o código pós-loop? Argumente que as pós-condições são satisfeitas.</li>
          <li>Forneça o pseudocódigo.</li>
          <li>Considere os casos especiais a seguir e indique, caso necessário,
            quais adaptações devem ser feitas no algoritmo para atendê-los.
            (i) A lista tem apenas \(1\) elemento. (ii) Nenhum elemento é maior que o pivô.
            (iii) Exceto o pivô, todo os outros elementos são maiores que o pivô.</li>
          <li>Forneça a complexidade de tempo de pior caso em notação \(\Theta\).</li>
        </ol>
        </p>
        </p>
      </li>

      <li>
        <p><strong>Questão 2:</strong> Determine a complexidade do algoritmo abaixo
          em função do valor de \(n\). Forneça também a complexidade de cada linha.
          Cada execução de \(f(i)\) tem tempo \( \Theta(i) \), cada execução de \(g(j)\)
          tem tempo \( \Theta(\log{n}) \), e cada execução de \(h(i)\) tem tempo \(\Theta(n^2)\).<br>
        <pre><code>
            algoritmo(n):
            1 para i de 1 até n
            2 f(i)
            3 para j de i+1 até n
            4 g(j)
            5 para i de 1 até n
            6 h(i)
          </code></pre>
        </p>
      </li>

    </ul>

  </body>

  </html>
